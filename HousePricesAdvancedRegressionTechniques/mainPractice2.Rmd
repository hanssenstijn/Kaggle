---
title: "House Prices"
author: "Stijn Hanssen"
date: "15 November 2018"
output: html_document
---

### Clear working space
First step is to make sure that the working space is empty.
```{r}
# clear all variables
rm(list=ls()) 
```

### Load packages
Loading the required packages for specific functions. If the packaged aren't present, they will be automatically be downloaded.
```{r}
if (!require("pacman")) suppressPackageStartupMessages(install.packages("pacman"))
pacman::p_load("stringr","GLDEX","RSEIS","DescTools","caret","plyr","Metrics","knitr","ggplot2","plyr","dplyr","corrplot","caret","gridExtra","scales","Rmisc","ggrepel","randomForest","psych","xgboost")
```

### Set working directory
Choose the path were the data-sets are stored.
```{r}
DATA.DIR <- "~/GitHub/Kaggle/HousePricesAdvancedRegressionTechniques"
setwd(DATA.DIR)
# See which files are in WD
list.files() 
```

### Import data
The training and test set will be imported. stringsAsFactors will be set to False in order to prevent that the character columns will be set to factor variables.
```{r}
train <- read.csv("train.csv",stringsAsFactors = F)
test <- read.csv("test.csv", stringsAsFactors =  F)
```

### Check and edit the datasets
The structure shows that the variables are integers or characters. Furthermore, the iD variables can be removed from both datasets. But for the prediction of the test set we will need the Id variable thus those will be saved. The test set does not contain Saleprices, thus we will create it and give it "Na" values. Now that the datasets have equal rows and columns they will be combined.
```{r}
str(train)

train$Id = NULL
testID = test$Id
test$Id = NULL

test$SalePrice = NA

df.combined = rbind(train,test)
dim(df.combined)
```

### Exploring and visualizing the data
The summary of the Saleprice column shows that the average price for selling a house is `180921`. The median is lower than the mean thus the data will be Right-Skewed (Positive skewed), this is shown in the histogram.
```{r}
summary(df.combined$SalePrice)
ggplot(data=df.combined[!is.na(df.combined$SalePrice),],aes(x=SalePrice)) +
    geom_histogram(fill="blue",binwidth=10000)
```

### Determine the correlation of the numeric variables towards Saleprice
First a new dataset will be created containing only the nummeric variables. Correlation will be calculated to determine which variables correlate with others. For sale price we see that `OverallQual` and `GrLivArea` are the highest correlated to SalePrice.
```{r}
# store the numeric variables
idx = which(sapply(df.combined, is.numeric))
numVar = names(idx)
df.num = df.combined[,numVar]
# calculate the correlation
corNum = cor(df.num,use="pairwise.complete.obs")

# select and sort on SalePrice
corSorted <- as.matrix(sort(corNum[,'SalePrice'], decreasing = TRUE))
# select only corelations above 0.5
CorHigh <- names(which(apply(corSorted, 1, function(x) abs(x)>0.5)))
corNum <- corNum[CorHigh, CorHigh]

corrplot.mixed(corNum, tl.col="black", tl.pos = "lt")
```

### Investigate the variables OverQuall and GrLivArea
As expected the improvement in Quality score of the house results in a higher house price. The Above grade (ground) living area square feet shows that there are two houses with a very high `GrLivArea` but nonetheless very low `SalePrice` which might indicate that these two points are outliers.
```{r}
ggplot(data=df.combined[!is.na(df.combined$SalePrice),],aes(x=as.factor(OverallQual),y=SalePrice)) +
    geom_boxplot()
ggplot(data=df.combined[!is.na(df.combined$SalePrice),],aes(x=GrLivArea,y=SalePrice)) +
    geom_point() +
    geom_smooth(method="lm")
which(df.combined$GrLivArea > 4500)
# 2550 is from the test set so it wont have a saleprice
df.combined[c(524,1299),c('SalePrice',"GrLivArea","OverallQual")]
```

### Handeling missing data
In total 35 have missing values, whereas one of them is the SalePrice which we had set to Na for the test set (meaning that we are gonne clean 34 variables). The variables with  the highest amount of missing values are for the `PoolQC`, `MiscFeature`,`Alley` and `Fence`.
```{r}
na.cols <- which(colSums(is.na(df.combined)) > 0)
sort(colSums(sapply(df.combined[na.cols], is.na)), decreasing = TRUE)
```

#### PoolQC
   Ex   Excellent
   Gd   Good
   TA   Average/Typical
   Fa   Fair
   NA   No Pool
Pool quallity seems to be ordinal. Were No pool is the lowest and Exellent pool can be set as the highest.
```{r}
table(df.combined$PoolQC)
df.combined$PoolQC[is.na(df.combined$PoolQC)] = "None"
# label encoding variable
qualities <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
df.combined$PoolQC = as.integer(revalue(df.combined$PoolQC,qualities))
table(df.combined$PoolQC)
sum(table(df.combined$PoolQC))
```
Do all the house that have a pool (determined by pool quality) also have a pool area. We see that 3 variables do have a pool area but not a pool quality, these will get their quality score based on the overall house quality.
```{r}
which(df.combined$PoolQC > 0 & df.combined$PoolArea == 0)
which(df.combined$PoolQC == 0 & df.combined$PoolArea > 0)
df.combined[c(2421,2504,2600),c("PoolArea","PoolQC","OverallQual")]
df.combined$PoolQC[2421] = 4
df.combined$PoolQC[2504] = 5
df.combined$PoolQC[2600] = 2
which(df.combined$PoolQC == 0 & df.combined$PoolArea > 0)
sum(table(df.combined$PoolQC))
```



