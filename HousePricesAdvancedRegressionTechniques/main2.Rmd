---
title: "House Prices"
author: "Stijn Hanssen"
date: "1 November 2018"
output: html_document
---

### Clear working space
First step is to make sure that the working space is empty.
```{r}
# clear all variables
rm(list=ls()) 
```

### Load packages
Loading the required packages for specific functions. If the packaged aren't present, they will be automatically be downloaded.
ggplot for data visualization, stringr for extracting string paterns, matrix for matrix transformations, glmnet for rigde lass and elastinet, xgboost for gbm, metrics for rmse, caret for one hot encoding, e1071 for skewness, corrplot for correlation plot.
```{r}
if (!require("pacman")) suppressPackageStartupMessages(install.packages("pacman"))
pacman::p_load("stringr","GLDEX","RSEIS","DescTools","caret","ggplot2","Matrix","glmnet","xgboost","randomForest","Metrics","dplyr","scales","e1071","corrplot")
```

### Set working directory
Choose the path were the data-sets are stored
```{r}
DATA.DIR <- "~/GitHub/Kaggle/HousePricesAdvancedRegressionTechniques"
setwd(DATA.DIR)
# See which files are in WD
list.files() 
```

### Import data
combine the datasets (remove the id from both datasets and remove the saleprice from the train set)
```{r}
train <- read.csv("train.csv",stringsAsFactors = F,header = T)
test <- read.csv("test.csv", stringsAsFactors =  F,header = T)
df.combined <- rbind(within(train, rm('Id','SalePrice')), within(test, rm('Id')))
dim(df.combined)
```

## Check NA
```{r}
na.cols <- which(colSums(is.na(df.combined)) > 0)
sort(colSums(sapply(df.combined[na.cols], is.na)), decreasing = TRUE)
```

## Plotting categorical data
```{r}
plot.categoric <- function(cols, df){
  for (col in cols) {
    order.cols <- names(sort(table(df.combined[,col]), decreasing = TRUE))
  
    num.plot <- qplot(df[,col]) +
      geom_bar(fill = 'cornflowerblue') +
      geom_text(aes(label = ..count..), stat='count', vjust=-0.5) +
      theme_minimal() +
      scale_y_continuous(limits = c(0,max(table(df[,col]))*1.1)) +
      scale_x_discrete(limits = order.cols) +
      xlab(col) +
      theme(axis.text.x = element_text(angle = 30, size=12))
  
    print(num.plot)
  }
}
```

## Pool quality
10 house do have a pool. Check if houses with NA for Pool quality indeed have a poolArea set as 0. 3 houses have a pool area but not a pool quality. we assign these by mean of the known pools. the rest of the pools will be assigned 'None'.
```{r}
plot.categoric('PoolQC', df.combined)
df.combined[(df.combined$PoolArea > 0) & is.na(df.combined$PoolQC),c('PoolQC','PoolArea')]
df.combined[,c('PoolQC','PoolArea')] %>%
  group_by(PoolQC) %>%
  summarise(mean = mean(PoolArea), counts = n()) 
df.combined[2421,'PoolQC'] = 'Ex'
df.combined[2504,'PoolQC'] = 'Ex'
df.combined[2600,'PoolQC'] = 'Fa'
df.combined$PoolQC[is.na(df.combined$PoolQC)] = 'None'
```

## Garage
GarageType: Garage location
GarageYrBlt: Year garage was built
GarageFinish: Interior finish of the garage
GarageCars: Size of garage in car capacity
GarageArea: Size of garage in square feet
GarageQual: Garage quality
GarageCond: Garage condition

How many houses were built the same year their garage was built. Most of this datasets house were built at the same year so we can asume that the NA's did the same.
```{r}
length(which(df.combined$GarageYrBlt == df.combined$YearBuilt))
idx <- which(is.na(df.combined$GarageYrBlt))
df.combined[idx, 'GarageYrBlt'] <- df.combined[idx, 'YearBuilt']
```

check if garageArea and Cars are 0 and if the rest of the garage features have Na on these rows we can set them to 'None', assuming that they dont have a garage. For the house with GarageArea = 360 and GarageCars = 1, but NA's in the other columns, we can use the most frequent values for each columns from houses with a similar area and car count.
Now we can fill in any missing numeric values with 0 and categoric with 'None' since these houses recorded having 0 area and 0 cars in their garage.
```{r}
garage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')
df.combined[is.na(df.combined$GarageCond),garage.cols]

idx <- which(((df.combined$GarageArea < 370) & (df.combined$GarageArea > 350)) & (df.combined$GarageCars == 1))
names(sapply(df.combined[idx, garage.cols], function(x) sort(table(x), decreasing=TRUE)[1]))
df.combined[2127,'GarageQual'] = 'TA'
df.combined[2127, 'GarageFinish'] = 'Unf'
df.combined[2127, 'GarageCond'] = 'TA'

for (col in garage.cols){
  if (sapply(df.combined[col], is.numeric) == TRUE){
    df.combined[sapply(df.combined[col], is.na), col] = 0
  }
  else{
    df.combined[sapply(df.combined[col], is.na), col] = 'None'
  }
}
```

## Kitchen and Eletrical
KitchenQual: Kitchen quality
Electrical: Electrical system
```{r}
plot.categoric('KitchenQual', df.combined)
df.combined$KitchenQual[is.na(df.combined$KitchenQual)] = 'TA'

plot.categoric('Electrical', df.combined)
df.combined$Electrical[is.na(df.combined$Electrical)] = 'SBrkr'
```

## Basement
BsmtQual: Height of the basement
BsmtCond: General condition of the basement
BsmtExposure: Walkout or garden level basement walls
BsmtFinType1: Quality of basement finished area
BsmtFinSF1: Type 1 finished square feet
BsmtFinType2: Quality of second finished area (if present)
BsmtFinSF2: Type 2 finished square feet
BsmtUnfSF: Unfinished square feet of basement area
TotalBsmtSF: Total square feet of basement area
BsmtFullBath: Basement full bathrooms
BsmtHalfBath: Basement half bathrooms

Subset the basement. Almost all of the missing values for each categoric basement feature comes from houses with 0 on each features corresponding to area. We can fill in these values with 'None' since these houses certainly don't have basements. Rows 949, 1488 and 2349 are the only missing values from BsmtExposure, we can fill this with No as that is the most frequent value and these houses most likely don't have any exposure for their basements. 
```{r}
bsmt.cols <- names(df.combined)[sapply(names(df.combined), function(x) str_detect(x, 'Bsmt'))]

df.combined[is.na(df.combined$BsmtExposure),bsmt.cols]
plot.categoric('BsmtExposure', df.combined)
df.combined[c(949, 1488, 2349), 'BsmtExposure'] = 'No'

for (col in bsmt.cols){
  if (sapply(df.combined[col], is.numeric) == TRUE){
    df.combined[sapply(df.combined[col], is.na),col] = 0
  }
  else{
    df.combined[sapply(df.combined[col],is.na),col] = 'None'
  }
}
```

## Exterior
Exterior1st: Exterior covering on house
Exterior2nd: Exterior covering on house (if more than one material)
There is only 1 missing value for Exterior1st and Exterior2nd coming from the same hosue. We can fill this with 'Other' since the NA is likely due to having an exterior cover that is not listed.
```{r}
plot.categoric(c('Exterior1st', 'Exterior2nd'), df.combined)
idx <- which(is.na(df.combined$Exterior1st) | is.na(df.combined$Exterior2nd))
df.combined[idx,c('Exterior1st', 'Exterior2nd')]
df.combined$Exterior1st[is.na(df.combined$Exterior1st)] = 'Other'
df.combined$Exterior2nd[is.na(df.combined$Exterior2nd)] = 'Other'
```

## Type sale, home functionality rating, utilities
SaleType: Type of sale
Functional: Home functionality rating
Utilities: Type of utilities available

SaleType we can see what the SaleCondition of the house was and use a contingency table to see which SaleType and SaleCondition overlap together the most. Most houses with a SaleCondition of 'Normal' almost all have a SaleType of 'WD'. We'll replace the missing value accordingly.
Utilities only has 1 value for NoSeWa and the rest AllPub. We can drop this feature from our dataset as the house with 'NoSeWa' is from our training set and will have won't help with any predictive modelling
```{r}
plot.categoric('SaleType', df.combined)
df.combined[is.na(df.combined$SaleType),c('SaleCondition')]
table(df.combined$SaleCondition, df.combined$SaleType)
df.combined$SaleType[is.na(df.combined$SaleType)] = 'WD'

plot.categoric('Functional', df.combined)
df.combined$Functional[is.na(df.combined$Functional)] = 'Typ'

plot.categoric('Utilities', df.combined)
which(df.combined$Utilities == 'NoSeWa')
col.drops <- c('Utilities')
df.combined <- df.combined[,!names(df.combined) %in% c('Utilities')]
```

## MSZoning and MSSUBclass
We can see what the subclass is for the houses with missing values for Zoning. For Subclasses with 20 'RL' has the largest frequency, however, for Subclasses with 30 and 70 'RM' has the most frequency. We will fill the missing values accordingly.
```{r}
df.combined[is.na(df.combined$MSZoning),c('MSZoning','MSSubClass')]
plot.categoric('MSZoning', df.combined)
table(df.combined$MSZoning, df.combined$MSSubClass)
df.combined$MSZoning[c(2217, 2905)] = 'RL'
df.combined$MSZoning[c(1916, 2251)] = 'RM'
```

## Masonry
For the house with a MasVnrArea of 198 but NA for MasVnrType we can record the median areas for each type and see which type is closest to 198
```{r}
df.combined[(is.na(df.combined$MasVnrType)) | (is.na(df.combined$MasVnrArea)), c('MasVnrType', 'MasVnrArea')]
na.omit(df.combined[,c('MasVnrType','MasVnrArea')]) %>%
  group_by(na.omit(MasVnrType)) %>%
  summarise(MedianArea = median(MasVnrArea,na.rm = TRUE), counts = n()) %>%
  arrange(MedianArea)
plot.categoric('MasVnrType', df.combined)
df.combined[2611, 'MasVnrType'] = 'BrkFace'
df.combined$MasVnrType[is.na(df.combined$MasVnrType)] = 'None'
df.combined$MasVnrArea[is.na(df.combined$MasVnrArea)] = 0
```

## Lotfrontage
There are 486 missing values for LotFrontage, which is quite a lot of values to fill. "LotFrontage: Linear feet of street connected to property." The area of each street connected to the house property is most likely going to have a similar area to other houses in its neighborhood. We can group by each neighborhood and take the median of each LotFrontage and fill the missing values of each LotFrontage based on what neighborhood the house comes from.
```{r}
df.combined['Nbrh.factor'] <- factor(df.combined$Neighborhood, levels = unique(df.combined$Neighborhood))

lot.by.nbrh <- df.combined[,c('Neighborhood','LotFrontage')] %>%
  group_by(Neighborhood) %>%
  summarise(median = median(LotFrontage, na.rm = TRUE))
lot.by.nbrh

idx = which(is.na(df.combined$LotFrontage))

for (i in idx){
  lot.median <- lot.by.nbrh[lot.by.nbrh == df.combined$Neighborhood[i],'median']
  df.combined[i,'LotFrontage'] <- lot.median[[1]]
}
```

## Fence Quality and MiscFeature

```{r}
plot.categoric('Fence', df.combined)
df.combined$Fence[is.na(df.combined$Fence)] = 'None'

table(df.combined$MiscFeature)
df.combined$MiscFeature[is.na(df.combined$MiscFeature)] = 'None'
```

## Fireplaces
Fireplaces: Number of fireplaces
FireplaceQu: Fireplace quality

All the houses that have missing values did not record having any fireplaces. We can replace the NA's with 'None' since these houses don't have any fireplaces at all.
```{r}
plot.categoric('FireplaceQu', df.combined)
which((df.combined$Fireplaces > 0) & (is.na(df.combined$FireplaceQu)))
df.combined$FireplaceQu[is.na(df.combined$FireplaceQu)] = 'None'
```

## Alley

```{r}
plot.categoric('Alley', df.combined)
df.combined$Alley[is.na(df.combined$Alley)] = 'None'
```

## Custom numeric features


